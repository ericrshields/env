#!/bin/bash

# Source global definitions
[[ -f /etc/bashrc ]] && . /etc/bashrc

# Preferences
# @author smoeller
# export VERBOSE_ENV_LOADING="true"
export EDITOR='vim -O'
export HISTSIZE=10000
export HISTTIMEFORMAT='%F %T '
export LESSHISTFILE=/dev/null
shopt -s cdspell
#shopt -s globstar

# Prompt
# Assumes that 'gitprompt.pl' in the $PATH
# @author mcanz; ewastl; and others
# Define the prompt format but don't set it as PS0
export GIT_PROMPT='\n\[\e[0;33m\]\u@\[\e[0m\]\[\e[0;31m\]\h\[\e[0m\] {\[\e[1;33m\]\w\[\e[0m\]}\[\e[0;36m\]%{(%b\[\e[1;37m\]%m\[\e[0;36m\])[%u%c%f%t\[\e[0;36m\]]%}\[\e[0m\]\n\[\e[0;36m\]\t\[\e[0m\] $ '

# Use GIT_PROMPT_FORMAT instead of PS0
if [ -z "${PROMPT_COMMAND}" ]; then
  export PROMPT_COMMAND='export PS1=$(gitprompt.pl statuscount=1 u=%[%e[31m%] c=%[%e[32m%] f=%[%e[1\;37m%])'
else
  export PROMPT_COMMAND=$PROMPT_COMMAND';export PS1=$(gitprompt.pl statuscount=1 u=%[%e[31m%] c=%[%e[32m%] f=%[%e[1\;37m%])'
fi

# Utilities
# Check modern ~/.local/bin first, fall back to legacy ~/bin for backwards compatibility
if [[ -f ~/.local/bin/git-completion.sh ]]; then
    [[ "$VERBOSE_ENV_LOADING" == "true" ]] && echo "Loading: ~/.local/bin/git-completion.sh"
    . ~/.local/bin/git-completion.sh && complete -o default -o nospace -F _git g gb
elif [[ -f ~/bin/git-completion.sh ]]; then
    [[ "$VERBOSE_ENV_LOADING" == "true" ]] && echo "Loading: ~/bin/git-completion.sh"
    . ~/bin/git-completion.sh && complete -o default -o nospace -F _git g gb
fi
if [[ -f ~/.local/bin/up.sh ]]; then
    [[ "$VERBOSE_ENV_LOADING" == "true" ]] && echo "Loading: ~/.local/bin/up.sh"
    . ~/.local/bin/up.sh && complete -o bashdefault -o default -o filenames -o nospace -F _up up
elif [[ -f ~/bin/up.sh ]]; then
    [[ "$VERBOSE_ENV_LOADING" == "true" ]] && echo "Loading: ~/bin/up.sh"
    . ~/bin/up.sh && complete -o bashdefault -o default -o filenames -o nospace -F _up up
fi

# Aliases
	# Git aliases
	# @author smoeller
	alias g='git'
	# @author mcanz
	alias gs='git status'
	alias gco='git checkout'
	alias gci='git commit'
	alias glg="git log -n 20 --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset %an' --abbrev-commit --date=relative"
	# @author dellis
	alias gdw='git diff --word-diff=color --word-diff-regex=.'
	# @author eshields
	alias gl='git log -n 20 --no-merges --abbrev-commit --abbrev=9'
	alias gll='git log --pretty=full'

	# Sets all directories (and files with execute bit originally set) to 755 and all other files to 644
	# author http://superuser.com/a/91966
	alias default_permissions='sudo chmod -R u+rwX,go+rX,go-w'

	# Common aliases
	# @author smoeller
	alias l='ls -AFh --color'
	alias ll='ls -AFh --color -l'
	alias vi='vim'
	# @author eshields
	alias sudo='sudo '

# Functions
	# Search for a directory or file matching a given regex
	# Renamed from fd/ff to avoid conflict with modern fd tool
	# Use modern 'fd' tool instead: fd -t d "pattern"
	# @author smoeller/eshields
	finddir() { find ${2:-.} ! -readable -prune -o -regextype posix-extended -iregex ".*($1)[^/]*" -type d -print | grep -v '\.[git|swp]$'; }
	findfile() { find ${2:-.} ! -readable -prune -o -regextype posix-extended -iregex ".*($1)[^/]*" \( -type f -or -type l \) -print | grep -v '\.swp$'; }

	# Git log search - uses native git grep for efficiency
	# @author eshields (modernized)
	logs() {
		git log --no-merges --abbrev-commit --abbrev=9 --grep="$1" --color=always
	}

	# Locate the line number and source file for a user defined shell function
	# @author HairOfTheDog http://superuser.com/a/229038
	functions() {
		shopt -s extdebug
		declare -F $1
		shopt -u extdebug
	}

	# Function to save an existing function to a new name
	save_func() {
		local ORIG_FUNC=$(declare -f $1)
		local NEWNAME_FUNC="$2${ORIG_FUNC#$1}"
		eval "$NEWNAME_FUNC"
	}

	# Show Claude Code session information for all directories
	# Rewritten to use jq for proper JSON parsing
	# @author eshields (modernized)
	claude-sessions() {
		for dir in ~/.claude/projects/*; do
			if [[ -f "$dir/sessions-index.json" ]]; then
				echo "Project: $(jq -r '.projectPath // "unknown"' "$dir/sessions-index.json" 2>/dev/null || echo "error parsing")"
				echo "Sessions: $(jq '[.sessions // []] | length' "$dir/sessions-index.json" 2>/dev/null || echo "error")"
				echo "Last modified: $(stat -c %y "$dir" | cut -d'.' -f1)"
				echo ""
			fi
		done
	}

# Environment-based settings - layered configuration system
# Configs load in order: base → context → environment → project
# Later layers override earlier settings
# Set VERBOSE_ENV_LOADING=true to see what configs are being loaded

# Helper function for verbose loading output
_env_load() {
    [[ "$VERBOSE_ENV_LOADING" == "true" ]] && echo "Loading: $1"
    . "$1"
}

# Base layer: Manual config (if present)
if [[ -f ~/.bash_local ]]; then
    _env_load ~/.bash_local
fi

# Secrets layer: API tokens and credentials (never version this file!)
if [[ -f ~/.secrets ]]; then
    _env_load ~/.secrets
fi

# Context layer: Work or Home (home is default)
if [[ -f ~/env/.env-marker-work ]]; then
    if [[ -f ~/env/bash/local/context-work ]]; then
        _env_load ~/env/bash/local/context-work
    fi
else
    if [[ -f ~/env/bash/local/context-home ]]; then
        _env_load ~/env/bash/local/context-home
    fi
fi

# Environment layer: WSL or Cloud (or neither)
if [[ -n "$WSL_DISTRO_NAME" ]] || [[ -n "$WSL_INTEROP" ]]; then
    # WSL environment (auto-detected)
    if [[ -f ~/env/bash/local/environment-wsl ]]; then
        _env_load ~/env/bash/local/environment-wsl
    fi
elif [[ -f ~/env/.env-marker-cloud ]]; then
    # Cloud environment (marker-based)
    if [[ -f ~/env/bash/local/environment-cloud ]]; then
        _env_load ~/env/bash/local/environment-cloud
    fi
fi

# Project layer: Dynamic loading of all projects
# Looks for .env-marker-project-* files and loads corresponding project-* configs
for marker in ~/env/.env-marker-project-*; do
    if [[ -f "$marker" ]]; then
        # Extract project name from marker filename
        project_name=$(basename "$marker" | sed 's/^\.env-marker-project-//')
        project_file=~/env/bash/local/project-$project_name
        if [[ -f "$project_file" ]]; then
            _env_load "$project_file"
        fi
    fi
done

# NVM setup
export NVM_DIR="${HOME}/.nvm"
if [ -s "$NVM_DIR/nvm.sh" ]; then
    [[ "$VERBOSE_ENV_LOADING" == "true" ]] && echo "Loading: $NVM_DIR/nvm.sh"
    \. "$NVM_DIR/nvm.sh"
fi
if [ -s "$NVM_DIR/bash_completion" ]; then
    [[ "$VERBOSE_ENV_LOADING" == "true" ]] && echo "Loading: $NVM_DIR/bash_completion"
    \. "$NVM_DIR/bash_completion"
fi
export NVM_SYMLINK_CURRENT="true" # Tell nvm to create ~/.nvm/current/ symlink that points to currently active version
export PATH="${HOME}/.nvm/current/bin:"$PATH

# Add Claude and similar products that use .local
export PATH="${HOME}/.local/bin:"$PATH

# Make home bin the highest override
export PATH="${HOME}/bin:"$PATH
